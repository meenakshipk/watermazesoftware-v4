/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package wmsoftware;

import ij.io.FileSaver;
import ij.ImagePlus;
import ij.gui.OvalRoi;
import ij.gui.Plot;
import ij.gui.PlotWindow;
import ij.gui.Roi;
import ij.measure.CurveFitter;
import ij.process.FloatProcessor;
import ij.process.ImageProcessor;
import ij.plugin.filter.*;
import ij.process.Blitter;
import java.awt.Component;
import java.awt.Image;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.io.File;
import java.io.Serializable;
import java.util.ArrayList;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Collections;
import java.util.HashMap;
import java.util.NoSuchElementException;

/**
 *
 * @author Meenakshi
 */
public class WMSoftwareGUI extends javax.swing.JFrame {

    private int totalMiceNo;
    private int totalTrialNo;
    private File dir;
    private DataStore[] dss;
    private Component frame;
    private double userBin;
    private int dimX = 240;
    private int dimY = 240;
    private int pX = 175;
    private int pY = 175;

    /**
     * Creates new form WMSoftwareGUI
     */
    public WMSoftwareGUI() {
        initComponents();
        jComboBoxTrialNo.removeAllItems();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jDialog1 = new javax.swing.JDialog();
        jLabel3 = new javax.swing.JLabel();
        buttonGroupPlotGroupDataBy = new javax.swing.ButtonGroup();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jTextFieldTrials = new javax.swing.JTextField();
        jTextFieldTotalMiceNo = new javax.swing.JTextField();
        jButton1 = new javax.swing.JButton();
        jComboBoxTrialNo = new javax.swing.JComboBox<>();
        jLabel4 = new javax.swing.JLabel();
        jButtonUploadFiles = new javax.swing.JButton();
        jButtonReadFiles = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jLabelMaps = new javax.swing.JLabel();
        jCheckBoxRDist = new javax.swing.JCheckBox();
        jCheckBoxRVel = new javax.swing.JCheckBox();
        jCheckBoxRVelaP = new javax.swing.JCheckBox();
        jCheckBoxRVelpP = new javax.swing.JCheckBox();
        jCheckBoxRVelErr = new javax.swing.JCheckBox();
        jButtonCalculateMeasures = new javax.swing.JButton();
        jCheckBoxResTime = new javax.swing.JCheckBox();
        jCheckBoxASCIIvector = new javax.swing.JCheckBox();
        jCheckBoxHeatMap = new javax.swing.JCheckBox();
        jLabelMaps1 = new javax.swing.JLabel();
        jCheckBoxDivergence = new javax.swing.JCheckBox();
        jCheckBoxCurl = new javax.swing.JCheckBox();
        jCheckBoxGradient = new javax.swing.JCheckBox();
        jButtonGenerateMaps = new javax.swing.JButton();
        jPanel3 = new javax.swing.JPanel();
        jCheckBoxRDistvRVel = new javax.swing.JCheckBox();
        jCheckBoxRDistvRVelaP = new javax.swing.JCheckBox();
        jCheckBoxRDistvRVelpP = new javax.swing.JCheckBox();
        jCheckBoxRDistvRVelErr = new javax.swing.JCheckBox();
        jLabelPlots = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jTextFieldUserBin = new javax.swing.JTextField();
        jLabel8 = new javax.swing.JLabel();
        jCheckBoxIndividualMouse2 = new javax.swing.JCheckBox();
        jCheckBoxAveMouse2 = new javax.swing.JCheckBox();
        jButton2 = new javax.swing.JButton();

        jDialog1.setTitle("Select files");
        jDialog1.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        jDialog1.setModalityType(java.awt.Dialog.ModalityType.DOCUMENT_MODAL);

        jLabel3.setText("Select files for each trial:");

        javax.swing.GroupLayout jDialog1Layout = new javax.swing.GroupLayout(jDialog1.getContentPane());
        jDialog1.getContentPane().setLayout(jDialog1Layout);
        jDialog1Layout.setHorizontalGroup(
            jDialog1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jDialog1Layout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addComponent(jLabel3)
                .addContainerGap(259, Short.MAX_VALUE))
        );
        jDialog1Layout.setVerticalGroup(
            jDialog1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jDialog1Layout.createSequentialGroup()
                .addGap(26, 26, 26)
                .addComponent(jLabel3)
                .addContainerGap(260, Short.MAX_VALUE))
        );

        jDialog1.getAccessibleContext().setAccessibleParent(jButton1);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Water Maze Software");

        jLabel1.setText("Number of mice per trial:");

        jLabel2.setText("Total number of trials:");

        jButton1.setText("Select Files");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jComboBoxTrialNo.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));

        jLabel4.setText("Trial number:");

        jButtonUploadFiles.setText("Upload Files");
        jButtonUploadFiles.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonUploadFilesActionPerformed(evt);
            }
        });

        jButtonReadFiles.setText("Read Files");
        jButtonReadFiles.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonReadFilesActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel1)
                            .addComponent(jLabel2))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(jTextFieldTrials, javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(jTextFieldTotalMiceNo, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 96, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 94, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jComboBoxTrialNo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonUploadFiles)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonReadFiles)
                        .addGap(0, 204, Short.MAX_VALUE))))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jTextFieldTotalMiceNo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(jTextFieldTrials, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jButton1)
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(jComboBoxTrialNo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButtonUploadFiles)
                    .addComponent(jButtonReadFiles))
                .addContainerGap(184, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Select Files", jPanel1);

        jLabelMaps.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabelMaps.setText("Measures:");

        jCheckBoxRDist.setText("Displacement");

        jCheckBoxRVel.setText("Velocity");

        jCheckBoxRVelaP.setText("Velocity along platform");

        jCheckBoxRVelpP.setText("Velocity perpendicular to platform");

        jCheckBoxRVelErr.setText("Velocity Error");

        jButtonCalculateMeasures.setText("Calculate");
        jButtonCalculateMeasures.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonCalculateMeasuresActionPerformed(evt);
            }
        });

        jCheckBoxResTime.setText("Residence Time");

        jCheckBoxASCIIvector.setText("ASCII vector");

        jCheckBoxHeatMap.setText("Heat map");

        jLabelMaps1.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabelMaps1.setText("Maps:");

        jCheckBoxDivergence.setText("Divergence map");

        jCheckBoxCurl.setText("Curl map");

        jCheckBoxGradient.setText("Gradient map");

        jButtonGenerateMaps.setText("Generate Maps");
        jButtonGenerateMaps.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonGenerateMapsActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jCheckBoxResTime)
                    .addComponent(jLabelMaps)
                    .addComponent(jCheckBoxRDist)
                    .addComponent(jCheckBoxRVelpP)
                    .addComponent(jCheckBoxRVel)
                    .addComponent(jCheckBoxRVelaP)
                    .addComponent(jButtonCalculateMeasures)
                    .addComponent(jCheckBoxRVelErr))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 44, Short.MAX_VALUE)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jCheckBoxASCIIvector)
                    .addComponent(jLabelMaps1)
                    .addComponent(jCheckBoxHeatMap)
                    .addComponent(jCheckBoxGradient)
                    .addComponent(jCheckBoxDivergence)
                    .addComponent(jCheckBoxCurl)
                    .addComponent(jButtonGenerateMaps))
                .addGap(173, 173, 173))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabelMaps)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxResTime)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxRDist)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxRVel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxRVelaP)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxRVelpP))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabelMaps1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxASCIIvector)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxHeatMap)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxDivergence)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxCurl)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxGradient)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRVelErr)
                .addGap(18, 18, 18)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButtonCalculateMeasures)
                    .addComponent(jButtonGenerateMaps))
                .addContainerGap(110, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Generate Maps", jPanel2);

        jCheckBoxRDistvRVel.setText("R-Distance vs R-Velocity");

        jCheckBoxRDistvRVelaP.setText("R-Distance vs R-Velocity along platform");

        jCheckBoxRDistvRVelpP.setText("R-Distance vs R-Velocity perpendicular to platform");

        jCheckBoxRDistvRVelErr.setText("R-Distance vs R-Velocity Errors");

        jLabelPlots.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabelPlots.setText("Plots:");

        jLabel5.setText("Enter bin width in X:");

        jTextFieldUserBin.setText("0.00");

        jLabel8.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabel8.setText("Output data:");

        jCheckBoxIndividualMouse2.setText("Individual mouse");

        jCheckBoxAveMouse2.setText("Average mouse");

        jButton2.setText("jButton2");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabelPlots)
                    .addComponent(jCheckBoxRDistvRVelErr)
                    .addComponent(jCheckBoxRDistvRVelpP)
                    .addComponent(jCheckBoxRDistvRVelaP)
                    .addComponent(jCheckBoxRDistvRVel)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(jLabel5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextFieldUserBin, javax.swing.GroupLayout.PREFERRED_SIZE, 51, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jLabel8)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(jCheckBoxIndividualMouse2)
                        .addGap(18, 18, 18)
                        .addComponent(jCheckBoxAveMouse2)))
                .addContainerGap(242, Short.MAX_VALUE))
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addComponent(jButton2)
                .addGap(0, 0, Short.MAX_VALUE))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGap(27, 27, 27)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5)
                    .addComponent(jTextFieldUserBin, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabelPlots)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRDistvRVel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRDistvRVelaP)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRDistvRVelpP)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRDistvRVelErr)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabel8)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jCheckBoxIndividualMouse2)
                    .addComponent(jCheckBoxAveMouse2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jButton2)
                .addContainerGap(69, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Generate Plots", jPanel3);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTabbedPane1)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTabbedPane1)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonCalculateMeasuresActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonCalculateMeasuresActionPerformed
        //BitSet for measures
        BitSet bs = new BitSet(6);
        bs.set(0, jCheckBoxResTime.isSelected());
        bs.set(1, jCheckBoxRDist.isSelected());
        bs.set(2, jCheckBoxRVel.isSelected());
        bs.set(3, jCheckBoxRVelaP.isSelected());
        bs.set(4, jCheckBoxRVelpP.isSelected());
        bs.set(5, jCheckBoxRVelErr.isSelected());

        //BitSet for output file type
        BitSet bs2 = new BitSet(5);
        bs2.set(0, jCheckBoxASCIIvector.isSelected());
        bs2.set(1, jCheckBoxHeatMap.isSelected());
        bs2.set(2, jCheckBoxDivergence.isSelected());
        bs2.set(3, jCheckBoxCurl.isSelected());
        bs2.set(4, jCheckBoxGradient.isSelected());

//        //Select directory to store files
//        JFileChooser Fc = new JFileChooser();
//        Fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
//        Fc.showOpenDialog(this);
//        dir = Fc.getSelectedFile();
        //loop through measures to be calculated
        for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {
            String resultName = "";
            String resultRName = "";

            //loop through trials
            for (DataStore ds : dss) {
                HashMap PositionHM = ds.getHMap("Position");

                HashMap resultHMap = new HashMap<>();
                HashMap resultRHMap = new HashMap<>();

                //loop through mice
                for (int mouse = 0; mouse < ds.getTotalMice(); mouse++) {
                    DataTrace_ver1 series = (DataTrace_ver1) PositionHM.get(mouse);

                    DataTrace_ver1 result = new DataTrace_ver1();
                    ArrayList<Double> resultR = new ArrayList<>();

                    //calculations
                    switch (i) {
                        case 0: //residence time
                            resultRName = "Residence Time";
                            resultR = this.residenceTime(series);
                            break;

                        case 1: //displacement
                            resultName = "Displacement";
                            result = this.displacementVector(series);
//                            resultRName = "Distance";
//                            resultR = this.vectorMagnitude(result);
                            break;

                        case 2: //velocity
                            resultName = "Velocity";
                            result = this.velocityVector(series);
//                            resultRName = "Speed";
//                            resultR = this.vectorMagnitude(result);
                            break;

                        case 3: //vel along pt
                            resultName = "Velocity along Platform";
                            result = this.velocityAlongPt(series);
//                            resultRName = "Speed along Platform";
//                            resultR = this.vectorMagnitude(result);
                            break;

                        case 4: //vel perpendicular pt
                            resultName = "Velocity perpendicular Platform";
                            result = this.velocityPerpendicularPt(series);
//                            resultRName = "Speed perpendicular Platform";
//                            resultR = this.vectorMagnitude(result);
                            break;

                        case 5: //vel err
                            resultName = "Velocity Error";
                            result = this.velocityErrorVector(series);
//                            resultRName = "Speed Error";
//                            resultR = this.vectorMagnitude(result);
                            break;
                    }
                    //put calculated measure in a hashmap
                    resultHMap.put(mouse, result);
                    resultRHMap.put(mouse, resultR);
                }
                //put calculated hashmap into datastore
                ds.setHMap(resultName, resultHMap);
                ds.setHMap(resultRName, resultRHMap);
            }
            if (i == Integer.MAX_VALUE) {
                break;
            }
        }

        //////                        if (jCheckBoxIndividualMouse1.isSelected() && i != 0) {
        //////
        //////                            ArrayList<Double> resultArray = result.getX();
        //////
        //////                            //image generation
        //////                            ArrayList<Double> sumPixel = map.sumPixelValue(series, resultArray);
        //////                            ArrayList<Double> resTimeWeightedPixel = new ArrayList<>();
        //////                            for (int ii = 0; ii < sumPixel.size(); ii++) {
        //////                                double averagedPixel;
        //////                                if (resultResTime.get(ii) == 0) {
        //////                                    averagedPixel = sumPixel.get(ii);
        //////                                } else {
        //////                                    averagedPixel = sumPixel.get(ii) / resultResTime.get(ii);
        //////                                }
        //////                                resTimeWeightedPixel.add(ii, averagedPixel);
        //////                            }
        //////                            ip = map.resTimeWeightedMap(resultResTime, resTimeWeightedPixel);
        //////                            ImagePlus image = new ImagePlus(resultName + "_T" + ds_counter + "_M" + mouse, ip);
        //////                            map.show(ip);
        //////                            map.saveHeatMap(resultName + "_T" + ds_counter + "_M" + mouse, ip);
        //////
        //////                            //polynomial surface fit
        //////                            //threshold out 0 values and create an ROI in restime image
        //////                            double minValue = 1;
        //////                            double maxValue = ipResTime.getMax();
        ////////                        System.out.println("minValue: " + minValue + "maxValue: " + maxValue);
        //////                            ipResTime.setThreshold(minValue, maxValue, 3);
        //////                            ThresholdToSelection tts = new ThresholdToSelection();
        //////                            Roi selectionROI = tts.convert(ipResTime);
        //////                            Rectangle bounds = selectionROI.getBounds();
        ////////                        System.out.println("Bounding rect" + bounds);
        //////                            image.setRoi(selectionROI);
        //////
        //////                            //polynomial fit function -
        //////                            Polynomial_Surface_Fit psf = new Polynomial_Surface_Fit(image);
        //////                            image = psf.run(ip);
        //////                            image.show();
        //////                            Differentials_JB diffJB = new Differentials_JB();
        //////                            diffJB.run2(image, 0);
        //////                            ip = image.getProcessor();
        //////                            ip.invert(); //so minima can be maxima
        //////
        //////                            //Find maxima within the pool ROI
        //////                            OvalRoi pool = new OvalRoi(0, 0, 240, 240);
        //////                            //find maxima
        //////                            MaximumFinder mf = new MaximumFinder();
        //////                            Polygon maximas = mf.getMaxima(ip, 0.00001, true); //excludes edges
        ////////                        System.out.println("Find Maxima: XCoord " + Arrays.toString(maximas.xpoints));
        ////////                        System.out.println("Find Maxima: YCoord " + Arrays.toString(maximas.ypoints));
        ////////                        System.out.println("Points: " + maximas.npoints + Arrays.toString(maximas.xpoints) + Arrays.toString(maximas.ypoints));
        //////
        //////                            ArrayList<Float> RmList = new ArrayList<>();
        //////                            ArrayList<Float> intensity = new ArrayList<>();
        //////                            int xb = (int) bounds.getX();
        //////                            int yb = (int) bounds.getY();
        //////                            for (int ii = 0; ii < maximas.npoints; ii++) {
        //////                                int X = maximas.xpoints[ii] + xb;
        //////                                int Y = maximas.ypoints[ii] + yb;
        //////                                if (pool.containsPoint(X, Y)) {
        //////                                    intensity.add(ip.getPixelValue(maximas.xpoints[ii], maximas.ypoints[ii]));
        //////                                    float Rm = (float) Math.sqrt(Math.pow((175 - X), 2) + Math.pow((175 - Y), 2));
        //////                                    RmList.add(Rm);
        //////                                }
        //////                            }
        //////                            float Rm;
        //////                            try {
        //////                                float max_intensity = Collections.max(intensity);
        //////                                int index = intensity.indexOf(max_intensity);
        //////                                Rm = RmList.get(index);
        //////                            } catch (NoSuchElementException c) {
        //////                                Rm = Float.NaN;
        //////                            }
        //////                            System.out.println("Rm list for all maximas UNSORTED: " + RmList);
        //////                            Collections.sort(RmList);
        //////                            System.out.println("Rm list for all maximas: " + RmList);
        //////                            HashMap rmHMap = ds.getHMap(resultName + " Rm Map") == null ? new HashMap<>() : ds.getHMap(resultName + " Rm Map");
        //////                            rmHMap.put(mouse, Rm);
        //////                            ds.setHMap(resultName + " Rm Map", rmHMap);
        //////
        //////                            //resize image to 240 by 240 dimension
        //////                            float[][] processedArray = new float[dimX][dimY];
        //////                            for (int Y = 0; Y < dimY; Y++) {
        //////                                for (int X = 0; X < dimX; X++) {
        //////                                    processedArray[X][Y] = Float.NaN;
        //////                                    //processedArray[X][Y] = 0;
        //////                                }
        //////                            }
        ////////                        int xb = (int) bounds.getX();  //already defined above
        ////////                        int yb = (int) bounds.getY();  // already defined above
        //////                            int xbmax = (int) bounds.getWidth();
        //////                            int ybmax = (int) bounds.getHeight();
        //////                            float[][] f = ip.getFloatArray();
        //////                            for (int Y = 0; Y < ybmax; Y++) {
        //////                                for (int X = 0; X < xbmax; X++) {
        //////                                    if (pool.containsPoint(X + xb, Y + yb)) {
        //////                                        processedArray[X + xb][Y + yb] = f[X][Y];
        //////                                    }
        //////                                }
        //////                            }
        //////                            ImageProcessor processedip = new FloatProcessor(processedArray);
        //////                            map.saveHeatMap(resultName + "processed_T" + ds_counter + "_M" + mouse, processedip);
        //////                        }
        System.out.println("Button click done.");
    }//GEN-LAST:event_jButtonCalculateMeasuresActionPerformed

    private void jButtonReadFilesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonReadFilesActionPerformed
        //reads the file and creates DataTrace for each file/mouse, in each trial
        for (DataStore ds : dss) {
            ds.readFile();
        }
        //print dialog box
        JOptionPane.showMessageDialog(frame, "Files read.", "Task completed", JOptionPane.INFORMATION_MESSAGE);
    }//GEN-LAST:event_jButtonReadFilesActionPerformed

    private void jButtonUploadFilesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonUploadFilesActionPerformed
        //choose multiple files
        JFileChooser Fc = new JFileChooser();
        Fc.setMultiSelectionEnabled(true);
        Fc.showOpenDialog(this);
        //creates DataStore for selected trial no.
        int index = jComboBoxTrialNo.getSelectedIndex();
        if (totalMiceNo != Fc.getSelectedFiles().length) {
            JOptionPane.showMessageDialog(frame, "Number of files selected does not match number of mice.", "ERROR", JOptionPane.ERROR_MESSAGE);
        } else {
            dss[index] = new DataStore(totalMiceNo, Fc.getSelectedFiles());
        }
    }//GEN-LAST:event_jButtonUploadFilesActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        jComboBoxTrialNo.removeAllItems();
        try {
            totalTrialNo = Integer.parseInt(jTextFieldTrials.getText());
            totalMiceNo = Integer.parseInt(jTextFieldTotalMiceNo.getText());
            if (totalTrialNo == 0 || totalMiceNo == 0) {
                JOptionPane.showMessageDialog(frame, "Enter valid number.", "ERROR", JOptionPane.ERROR_MESSAGE);
                return;
            }
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(frame, "Enter valid number.", "ERROR", JOptionPane.ERROR_MESSAGE);
        }
        //create checkbox with total trial no.
        for (int i = 0; i < totalTrialNo; i++) {
            jComboBoxTrialNo.addItem(Integer.toString(i + 1));
        }
        //create array for DataStore of all trials
        dss = new DataStore[totalTrialNo];
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jButtonGenerateMapsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonGenerateMapsActionPerformed
        // TODO add your handling code here:

        //Select directory to store files
        JFileChooser Fc = new JFileChooser();
        Fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        Fc.showOpenDialog(this);
        dir = Fc.getSelectedFile();

        //BitSet for measures
        BitSet bs = new BitSet(6);
        bs.set(0, jCheckBoxResTime.isSelected());
        bs.set(1, jCheckBoxRDist.isSelected());
        bs.set(2, jCheckBoxRVel.isSelected());
        bs.set(3, jCheckBoxRVelaP.isSelected());
        bs.set(4, jCheckBoxRVelpP.isSelected());
        bs.set(5, jCheckBoxRVelErr.isSelected());

        //BitSet for user selected output file type
        BitSet bs2 = new BitSet(5);
        bs2.set(0, jCheckBoxASCIIvector.isSelected());
        bs2.set(1, jCheckBoxDivergence.isSelected());
        bs2.set(2, jCheckBoxCurl.isSelected());
        bs2.set(3, jCheckBoxHeatMap.isSelected());
        bs2.set(4, jCheckBoxGradient.isSelected());

        String resultHMap = "";

        for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {
            //BitSet for output
            BitSet bs3 = new BitSet(5);

            switch (i) {
                case 0: //Residence Time
                    resultHMap = "Residence Time";
                    bs3.set(3, 5, true);
                    bs3.and(bs2);
                    break;
                case 1: //Displacement
                    resultHMap = "Displacement";
                    bs3.set(0, 5, true);
                    bs3.and(bs2);
                    break;
                case 2: //Velocity
                    resultHMap = "Velocity";
                    bs3.set(0, 5, true);
                    bs3.and(bs2);
                    break;
                case 3: //Velocity a pt
                    resultHMap = "Velocity along Platform";
                    bs3.set(0, 5, true);
                    bs3.and(bs2);
                    break;
                case 4: //Velocity p pt
                    resultHMap = "Velocity perpendicular Platform";
                    bs3.set(0, 5, true);
                    bs3.and(bs2);
                    break;
                case 5: //Velocity Error
                    resultHMap = "Velocity Error";
                    bs3.set(0, 5, true);
                    bs3.and(bs2);
                    break;
            }

            int ds_counter = 0;
            for (DataStore ds : dss) {
                HashMap HMap = ds.getHMap(resultHMap);
                for (int mouse = 0; mouse < ds.getTotalMice(); mouse++) {
                    DataTrace_ver1 measure = (DataTrace_ver1) HMap.get(mouse);

                    //calculate restime heatmap
                    HashMap ResTimeHMap = ds.getHMap("Residence Time");
                    ArrayList<Double> ResTime = (ArrayList<Double>) ResTimeHMap.get(mouse);

                    ImageProcessor ipResTime = new FloatProcessor(dimX, dimY);
                    float[][] arrayResTime = new float[dimX][dimY];
                    for (int Y = 0; Y < dimY; Y++) {
                        for (int X = 0; X < dimX; X++) {
                            int arrayIdx = (Y * dimX) + X;
                            arrayResTime[X][Y] = ResTime.get(arrayIdx).floatValue();
                        }
                    }
                    ipResTime.setFloatArray(arrayResTime);
                    this.saveHeatMap("ResTime_T" + ds_counter + "_M" + mouse, ipResTime);

                    //output type code
                    HashMap PositionHMap = ds.getHMap("Position");
                    DataTrace_ver1 series = (DataTrace_ver1) PositionHMap.get(mouse);

                    //loop through other selections
                    String output = "";
                    for (int j = bs3.nextSetBit(0); j >= 0; j = bs3.nextSetBit(j + 1)) {
                        //ImagePlus result = new ImagePlus();
                        ImagePlus result = null, xImage, yImage, image = null;
                        ArrayList<Double> rMeasure = null;
                        switch (j) {
                            case 0: //ASCII
                                //write vector measure into an ascii file
                                ds.writeFile(resultHMap + "_T" + ds_counter + "_M" + mouse, dir.getAbsolutePath(), measure);
                                break;
                            case 1: //Divergence
                                output = "div";
                                xImage = this.createImage(series, measure.getX());
                                yImage = this.createImage(series, measure.getY());
                                xImage = this.thresholdedSurfaceFit3(ipResTime, xImage);
                                yImage = this.thresholdedSurfaceFit3(ipResTime, yImage);
                                result = this.resizeImage(ipResTime, this.divergence(xImage, yImage).getProcessor());
                                //                       System.out.println("divergence" + "_T");
                                break;
                            case 2: //Curl
                                output = "curl";
                                xImage = this.createImage(series, measure.getX());
                                yImage = this.createImage(series, measure.getY());
                                xImage = this.thresholdedSurfaceFit3(ipResTime, xImage);
                                yImage = this.thresholdedSurfaceFit3(ipResTime, yImage);
                                result = this.resizeImage(ipResTime, this.curl(xImage, yImage).getProcessor());
                                //                       System.out.println("curl" + "_T");
                                break;
                            case 3: //Heat map
                                output = "hm";
                                rMeasure = this.vectorMagnitude(measure);
                                result = this.createImage(series, rMeasure);
                                //                       System.out.println("Heat map" + "_T");
                                break;
                            case 4: //Gradient
                                output = "grad";
                                rMeasure = this.vectorMagnitude(measure);
                                image = this.createImage(series, rMeasure);
                                image = this.thresholdedSurfaceFit3(ipResTime, image);
                                result = this.resizeImage(ipResTime, this.gradient(image).getProcessor());
                                //                       System.out.println("gradient" + "_T");
                                break;
                        }
                        if (j != 0) {
                            this.saveHeatMap(resultHMap + "_" + output + "_T" + ds_counter + "_M" + mouse, result.getProcessor());
                        }
                        if (j == Integer.MAX_VALUE) {
                            break;
                        }
                    }
                }
                ds_counter++;
                System.out.println("Trial no. = " + ds_counter);
            }
            System.out.println("Measure name: " + resultHMap + " completed");
            if (i == Integer.MAX_VALUE) {
                break;
            }
        }
        System.out.println("Button click done.");
    }//GEN-LAST:event_jButtonGenerateMapsActionPerformed

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        // TODO add your handling code here:
        if (jCheckBoxIndividualMouse2.isSelected() || jCheckBoxAveMouse2.isSelected()) {
            BitSet bs = new BitSet(4);

            bs.set(0, jCheckBoxRDistvRVel.isSelected());
            bs.set(1, jCheckBoxRDistvRVelaP.isSelected());
            bs.set(2, jCheckBoxRDistvRVelpP.isSelected());
            bs.set(3, jCheckBoxRDistvRVelErr.isSelected());

            //bin size for binning values
            userBin = Double.parseDouble(jTextFieldUserBin.getText());

            //Select directory to store files
            JFileChooser Fc = new JFileChooser();
            Fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
            Fc.showOpenDialog(this);
            dir = Fc.getSelectedFile();

            int ds_counter = 0;
            for (DataStore ds : dss) {
                HashMap dispHMap = ds.getHMap("Displacement");
                if (dispHMap.isEmpty()) {
                    JOptionPane.showMessageDialog(frame, "Displacement hashmap is empty. Please calculate displacement.", "ERROR", JOptionPane.ERROR_MESSAGE);
                    return;
                }

                for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {
                    String resultName = "";
                    switch (i) {

                        case 0: //rvel
                            resultName = "Velocity";
                            break;

                        case 1: //rvel along pt
                            resultName = "Velocity along Platform";
                            break;

                        case 2://rvel p pt
                            resultName = "Velocity perpendicular Platform";
                            break;

                        case 3://vel err
                            resultName = "Velocity Error";
                            break;
                    }

                    HashMap resultHMap = resultHMap = ds.getHMap(resultName);

                    int size = ds.getTotalMice();
                    for (int mouse = 0; mouse < size; mouse++) {
                        DataTrace_ver1 DispDt = (DataTrace_ver1) dispHMap.get(mouse);
                        DataTrace_ver1 resultDt = (DataTrace_ver1) resultHMap.get(mouse);
                        ArrayList<Double> dist = this.vectorMagnitude(DispDt);
                        ArrayList<Double> result = this.vectorMagnitude(resultDt);

                        //add xy data to datatrace
                        DataTrace_ver1 distVmeasure = new DataTrace_ver1();
                        for (int j = 0; j < dist.size() && j < result.size(); j++) {
                            distVmeasure.addData(dist.get(j), result.get(j));
                        }
                        //binInX and DO NOT restore original order
                        distVmeasure = distVmeasure.binData(userBin, true, false);

                        //1st: fit to polynomial, get parameters of fit and plot
                        //convert dataTrace's arraylist<Double> to double[]
                        ArrayList<Double> dbl = (ArrayList<Double>) distVmeasure.getX();
                        double[] xData = dbl.stream()
                                .mapToDouble(Double::doubleValue)
                                .toArray();
                        dbl = (ArrayList<Double>) distVmeasure.getY();
                        double[] yData = dbl.stream()
                                .mapToDouble(Double::doubleValue)
                                .toArray();
                        CurveFitter cf = new CurveFitter(xData, yData);
                        cf.doFit(CurveFitter.POLY2);
                        double[] para = cf.getParams();
                        Plot plot = cf.getPlot();

                        //2nd: save decorate plot and save plot
                        plot.setXYLabels("Distance", resultName);
                        String title = "Dist vs R" + resultName + "_M" + mouse;
//                        PlotWindow pw = plot.show();
//                        pw.setTitle(title);
                        ImagePlus imp = plot.getImagePlus();
                        imp.setTitle(title);
                        new FileSaver(imp).saveAsTiff(dir.getPath() + File.separator + title + ".tif");

                        //3rd: calculate Rm from fit parameters
                        double B0 = para[0];
                        double B1 = para[1];
                        double B2 = para[2];
                        double[] Rm = new double[3];
                        double det = 48.10488 + (72 * B1);
                        double thetam1 = (9.42 + Math.sqrt(det)) / 6;
                        double thetam2 = (9.42 - Math.sqrt(det)) / 6;
                        double RmValue = (Math.pow(thetam1, 2) - (3.14 * thetam1) + 3.287) / (2 * (B2 + 1));
                        Rm[0] = thetam1;
                        Rm[1] = thetam2;
                        Rm[2] = RmValue;
//TO DO - Save the calculated RmValue. In a hashmap? Write it out as a file?
                    }
                    if (i == Integer.MAX_VALUE) {
                        break;
                    }
                }
                ds_counter++;
            }
        } else {
            JOptionPane.showMessageDialog(frame, "Please select individual mouse or average mouse.", "ERROR", JOptionPane.ERROR_MESSAGE);
        }
        System.out.println("End of button press");
    }//GEN-LAST:event_jButton2ActionPerformed

//    /**
//     * Class Measures to calculate different water maze measures given xy data
//     * in the form of DataTrace_Ver1
//     */
//    private class Measures {
//
//        /**
//         * Default constructor
//         */
//        private Measures() {
//        }
    /**
     * Calculate vector magnitude i.e. r
     */
    private ArrayList<Double> vectorMagnitude(DataTrace_ver1 series) {
        ArrayList<Double> result = new ArrayList<>();
        for (int i = 0; i < series.size(); i++) {
            double x = series.get(i).getX().doubleValue();
            double y = series.get(i).getY().doubleValue();
            result.add(i, (Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))));
        }
        return result;
    }

    /**
     * Calculate vector angle i.e. theta
     */
    private ArrayList<Double> vectorAngle(DataTrace_ver1 series) {
        ArrayList<Double> result = new ArrayList<>();
        for (int i = 0; i < series.size(); i++) {
            double x = series.get(i).getX().doubleValue();
            double y = series.get(i).getY().doubleValue();
            if (x != 0) {
                result.add(i, Math.atan2(y, x)); //How to deal with x=0 error?
            } else {
                result.add(i, Double.MAX_VALUE);
            }
        }
        return result;
    }

    /**
     * Calculate (x(i+1) - x(i), y(i+1) - y(i))
     */
    private DataTrace_ver1 getSuccessiveDifference(DataTrace_ver1 series) {
        DataTrace_ver1 result = new DataTrace_ver1();
        for (int i = 0; i < (series.size() - 1); i++) {
            double x1 = series.get(i).getX().doubleValue();
            double x2 = series.get(i + 1).getX().doubleValue();
            double y1 = series.get(i).getY().doubleValue();
            double y2 = series.get(i + 1).getY().doubleValue();
            result.addData((x2 - x1), (y2 - y1));
        }
        return result;
    }

    /**
     * Calculate residence time
     */
    private ArrayList<Double> residenceTime(DataTrace_ver1 series) {
        ArrayList<Double> resTime = new ArrayList();
        for (int count = 0; count < (dimX * dimY); count++) {
            resTime.add(0d);
        }
        for (int i = 0; i < series.size(); i++) {
            double XPo = series.get(i).getX().doubleValue();
            double YPo = series.get(i).getY().doubleValue();
            int arrayIdx = (int) ((Math.round(YPo) * 240) + Math.round(XPo));
            resTime.set(arrayIdx, (resTime.get(arrayIdx) + 1));
        }
        return resTime;
    }

    /**
     * calculate displacement vector from the platform location
     */
    private DataTrace_ver1 displacementVector(DataTrace_ver1 series) {
        DataTrace_ver1 seriesCorr = new DataTrace_ver1();
        for (int i = 0; i < series.size(); i++) {
            double x = series.get(i).getX().doubleValue();
            double y = series.get(i).getY().doubleValue();
            seriesCorr.addData((pX - x), (pY - y));
        }
        return seriesCorr;
    }

//        /**
//         * calculate distance from the platform location given displacement
//         * vector
//         */
//        private ArrayList<Double> distance(DataTrace_ver1 series) {
//            ArrayList<Double> result = new ArrayList<>();
//            result = this.vectorMagnitude(series);
//            return result;
//        }
    /**
     * calculate velocity vector from the platform location
     */
    private DataTrace_ver1 velocityVector(DataTrace_ver1 series) {
        DataTrace_ver1 result = new DataTrace_ver1();
        DataTrace_ver1 displacement = this.displacementVector(series);
        //delvel                        
        result = this.getSuccessiveDifference(displacement);
        return result;
    }

    /**
     * calculate velocity components along and perpendicular to platform
     */
    private DataTrace_ver1 velocityComponents(DataTrace_ver1 series) {
        DataTrace_ver1 result = new DataTrace_ver1();

        DataTrace_ver1 displacementVector = this.displacementVector(series);
        ArrayList<Double> RDist = this.vectorMagnitude(displacementVector);
        DataTrace_ver1 velocityVector = this.velocityVector(series);
        ArrayList<Double> RVel = this.vectorMagnitude(velocityVector);
        ArrayList<Double> ThetaVel = new ArrayList<>();
        //Calculate ThetaVel and RVelaP
        for (int k = 0; k < (series.size() - 1); k++) {
            double delVel_x = velocityVector.get(k).getX().doubleValue();
            double delVel_y = velocityVector.get(k).getY().doubleValue();
            double seriesCorr_x = displacementVector.get(k).getX().doubleValue();
            double seriesCorr_y = displacementVector.get(k).getY().doubleValue();
            double value = ((delVel_x * seriesCorr_x) + (delVel_y * seriesCorr_y)) / (RDist.get(k) * RVel.get(k));
            ThetaVel.add(k, Math.acos(value));
            double xvalue = RVel.get(k) * Math.cos(ThetaVel.get(k));
            double yvalue = RVel.get(k) * Math.sin(ThetaVel.get(k));
            result.addData(xvalue, yvalue);
        }
        return result;
    }

    /**
     * calculate x and y of velocity components along platform
     */
    private DataTrace_ver1 velocityAlongPt(DataTrace_ver1 series) {
        DataTrace_ver1 result = new DataTrace_ver1();
        DataTrace_ver1 velocityComponents = this.velocityComponents(series);
        ArrayList<Double> theta = this.vectorAngle(this.displacementVector(series));
        for (int k = 0; k < velocityComponents.size(); k++) {
            double xvalue = (double) velocityComponents.getX().get(k) * Math.cos(theta.get(k));
            double yvalue = (double) velocityComponents.getX().get(k) * Math.sin(theta.get(k));
            result.addData(xvalue, yvalue);
        }
        return result;
    }

    /**
     * calculate x and y of velocity components perpendicular to platform
     */
    private DataTrace_ver1 velocityPerpendicularPt(DataTrace_ver1 series) {
        DataTrace_ver1 result = new DataTrace_ver1();
        DataTrace_ver1 velocityComponents = this.velocityComponents(series);
        ArrayList<Double> theta = this.vectorAngle(this.displacementVector(series));
        for (int k = 0; k < velocityComponents.size(); k++) {
            double xvalue = (double) velocityComponents.getY().get(k) * Math.cos(90 + theta.get(k));
            double yvalue = (double) velocityComponents.getY().get(k) * Math.sin(90 + theta.get(k));
            result.addData(xvalue, yvalue);
        }
        return result;
    }

    /**
     * calculate velocity error vectors
     */
    private DataTrace_ver1 velocityErrorVector(DataTrace_ver1 series) {
        DataTrace_ver1 result = new DataTrace_ver1();

        DataTrace_ver1 displacementVector = this.displacementVector(series);
        ArrayList<Double> RDist = this.vectorMagnitude(displacementVector);
        DataTrace_ver1 delVel = this.velocityVector(series);
        DataTrace_ver1 seriesCorr = this.displacementVector(series);

        //RVelErr Initialise
        DataTrace_ver1 cap = new DataTrace_ver1();

        //Calculate RVelErr
        for (int k = 0; k < (series.size() - 1); k++) {
            //calculate unit vector
            double seriesCorr_x = seriesCorr.get(k).getX().doubleValue();
            double seriesCorr_y = seriesCorr.get(k).getY().doubleValue();
            cap.addData((seriesCorr_x / RDist.get(k)), (seriesCorr_y / RDist.get(k)));
            //calculate velocity error vector - TO DO

        }
        return result;
    }

////////        /**
////////         * mean vec - is this needed now that datatrace has stats and provides mean? - TO DO
////////         */
////////        private XYDataItem meanVec(DataTrace_ver1 series) {
////////            double meanVx = 0;
////////            double meanVy = 0;
////////            for (int i = 0; i < series.getItemCount(); i++) {
////////                meanVx = meanVx + series.getX(i).doubleValue();
////////                meanVy = meanVy + series.getY(i).doubleValue();
////////            }
////////            meanVx = meanVx / series.getItemCount();
////////            meanVy = meanVy / series.getItemCount();
////////            XYDataItem result = new XYDataItem(meanVx, meanVy);
////////            System.out.println("meanVx" + meanVx + " meanVy" + meanVy + " n" + series.getItemCount());
////////
////////            return result;
////////        }
//    }
//    /**
//     * Class maps for generating heat maps from calculated measures
//     */
//    private class Maps {
//
//        /**
//         * default constructor
//         */
//        private Maps() {
//        }
//        /**
//         * show image
//         */
//        private void show(ImageProcessor ip) {
//            ImagePlus imp = new ImagePlus("", ip);
//            imp.show();
//        }
    /**
     * save heat map
     */
    private void saveHeatMap(String title, ImageProcessor ip) {
        ImagePlus imp = new ImagePlus(title, ip);
        new FileSaver(imp).saveAsTiff(dir.getPath() + File.separator + imp.getTitle() + ".tif");
    }

    /**
     * calculate each pixel value given xy data points in DataTrace_ver1
     */
    private ArrayList<Double> sumPixelValue(DataTrace_ver1 curSeries, ArrayList<Double> M) {
        ArrayList<Double> result = new ArrayList<>();
        for (int count = 0; count < (dimX * dimY); count++) {
            result.add(0d);
//                result.add(Float.NaN); //CANNOT USE THIS WHEN YOU WANT TO USE IMAGE FOR DIFFERENTIALS PLUGIN
        }

        int size = curSeries.size() - 1;
        for (int j = 0; j < size; j++) {
            double XPo = curSeries.get(j).getX().doubleValue();
            double YPo = curSeries.get(j).getY().doubleValue();
            int arrayIdx = (int) ((Math.round(YPo) * 240) + Math.round(XPo));
            result.set(arrayIdx, (result.get(arrayIdx) + M.get(j)));
//                CANNOT USE NANs WHEN USING DIFFERENTIALS PLUGIN
//                if (result.get(arrayIdx).isNaN()) {
//                    result.set(arrayIdx, M.get(j));
//                } else {
//                    result.set(arrayIdx, (result.get(arrayIdx) + M.get(j)));
//                }
        }
        return result;
    }

    /**
     * generate residence time weighted heat map
     */
    private ImageProcessor resTimeWeightedMap(ArrayList<Double> resTime, ArrayList<Double> measure) {

        ImageProcessor ip = new FloatProcessor(dimX, dimY);
        float[][] image = new float[dimX][dimY];
        for (int Y = 0; Y < dimY; Y++) {
            for (int X = 0; X < dimX; X++) {
                int arrayIdx = (Y * dimX) + X;
                if (resTime.get(arrayIdx) != 0) {
                    image[X][Y] = (float) (measure.get(arrayIdx) / resTime.get(arrayIdx));
//                    System.out.println(X + " " + Y + " Measure.get()arrayIdx: " + measure.get(arrayIdx) + " .floatValue(): " + measure.get(arrayIdx).floatValue());
                } else {
//                        image[X][Y] = Float.NaN;
                    image[X][Y] = 0f;
                }
            }
        }
        ip.setFloatArray(image);
        return ip;
    }

    /**
     * create image using an arraylist
     */
    private ImagePlus createImage(DataTrace_ver1 series, ArrayList<Double> measure) {
        ImagePlus image = new ImagePlus();
        ArrayList ImgArray = this.sumPixelValue(series, measure);
        ImageProcessor Img = this.resTimeWeightedMap(this.residenceTime(series), ImgArray);
        image.setProcessor(Img);
        return image;
    }

    /**
     * generate polynomial surface fit of order 3
     */
    private ImagePlus thresholdedSurfaceFit3(ImageProcessor ipResTime, ImagePlus image) {
        //threshold out 0 values and create an ROI in restime image
        double minValue = 1;
        double maxValue = ipResTime.getMax();
//        System.out.println("minValue: " + minValue + "maxValue: " + maxValue);
        ipResTime.setThreshold(minValue, maxValue, 3);
        ThresholdToSelection tts = new ThresholdToSelection();
        Roi selectionROI = tts.convert(ipResTime);
        Rectangle bounds = selectionROI.getBounds();
//        System.out.println("Bounding rect" + bounds);
        image.setRoi(selectionROI);

        //polynomial fit function -
        Polynomial_Surface_Fit psf = new Polynomial_Surface_Fit(image);
        image = psf.run(image.getProcessor());
//        image.show();
        return image;
    }

    /**
     * generate divergence
     */
    private ImagePlus divergence(ImagePlus xImage, ImagePlus yImage) {
        //differentiate image
        Differentials_JB diffJB = new Differentials_JB();
        diffJB.run2(xImage, 6); //differentiate wrt x        
        diffJB.run2(yImage, 7); //differentiate wrt y
        yImage.getProcessor().copyBits(xImage.getProcessor(), 0, 0, Blitter.ADD);
        return yImage;
    }

    /**
     * generate curl
     */
    private ImagePlus curl(ImagePlus xImage, ImagePlus yImage) {
        //differentiate image
        Differentials_JB diffJB = new Differentials_JB();
        diffJB.run2(yImage, 6); //differentiate wrt x
        diffJB.run2(xImage, 7); //differentiate wrt y        
        yImage.getProcessor().copyBits(xImage.getProcessor(), 0, 0, Blitter.DIFFERENCE);
        return yImage;
    }

    /**
     * generate curl
     */
    private ImagePlus gradient(ImagePlus image) {
        //differentiate image
        Differentials_JB diffJB = new Differentials_JB();
        diffJB.run2(image, 0); //differentiate wrt x
        return image;
    }

    /**
     * resize surface fit-differential images to dimX by dimY dimensions
     */
    private ImagePlus resizeImage(ImageProcessor ipResTime, ImageProcessor ip) {
        ImagePlus imp = new ImagePlus();
        OvalRoi pool = new OvalRoi(0, 0, 240, 240);

        //threshold out 0 values and create an ROI in restime image
        double minValue = 1;
        double maxValue = ipResTime.getMax();
//        System.out.println("minValue: " + minValue + "maxValue: " + maxValue);
        ipResTime.setThreshold(minValue, maxValue, 3);
        ThresholdToSelection tts = new ThresholdToSelection();
        Roi selectionROI = tts.convert(ipResTime);
        Rectangle bounds = selectionROI.getBounds();

//      resize image to 240 by 240 dimension
        float[][] processedArray = new float[dimX][dimY];
        for (int Y = 0; Y < dimY; Y++) {
            for (int X = 0; X < dimX; X++) {
                processedArray[X][Y] = Float.NaN;
//                processedArray[X][Y] = 0;
            }
        }
        int xb = (int) bounds.getX();  //already defined above
        int yb = (int) bounds.getY();  // already defined above
        int xbmax = (int) bounds.getWidth();
        int ybmax = (int) bounds.getHeight();
        float[][] f = ip.getFloatArray();
        for (int Y = 0; Y < ybmax; Y++) {
            for (int X = 0; X < xbmax; X++) {
                if (pool.containsPoint(X + xb, Y + yb)) {
                    processedArray[X + xb][Y + yb] = f[X][Y];
                }
            }
        }
        ImageProcessor processedip = new FloatProcessor(processedArray);
        imp.setProcessor(processedip);
        return imp;
    }

//    }
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;

                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(WMSoftwareGUI.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(WMSoftwareGUI.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(WMSoftwareGUI.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(WMSoftwareGUI.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new WMSoftwareGUI().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup buttonGroupPlotGroupDataBy;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButtonCalculateMeasures;
    private javax.swing.JButton jButtonGenerateMaps;
    private javax.swing.JButton jButtonReadFiles;
    private javax.swing.JButton jButtonUploadFiles;
    private javax.swing.JCheckBox jCheckBoxASCIIvector;
    private javax.swing.JCheckBox jCheckBoxAveMouse2;
    private javax.swing.JCheckBox jCheckBoxCurl;
    private javax.swing.JCheckBox jCheckBoxDivergence;
    private javax.swing.JCheckBox jCheckBoxGradient;
    private javax.swing.JCheckBox jCheckBoxHeatMap;
    private javax.swing.JCheckBox jCheckBoxIndividualMouse2;
    private javax.swing.JCheckBox jCheckBoxRDist;
    private javax.swing.JCheckBox jCheckBoxRDistvRVel;
    private javax.swing.JCheckBox jCheckBoxRDistvRVelErr;
    private javax.swing.JCheckBox jCheckBoxRDistvRVelaP;
    private javax.swing.JCheckBox jCheckBoxRDistvRVelpP;
    private javax.swing.JCheckBox jCheckBoxRVel;
    private javax.swing.JCheckBox jCheckBoxRVelErr;
    private javax.swing.JCheckBox jCheckBoxRVelaP;
    private javax.swing.JCheckBox jCheckBoxRVelpP;
    private javax.swing.JCheckBox jCheckBoxResTime;
    private javax.swing.JComboBox<String> jComboBoxTrialNo;
    private javax.swing.JDialog jDialog1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabelMaps;
    private javax.swing.JLabel jLabelMaps1;
    private javax.swing.JLabel jLabelPlots;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JTextField jTextFieldTotalMiceNo;
    private javax.swing.JTextField jTextFieldTrials;
    private javax.swing.JTextField jTextFieldUserBin;
    // End of variables declaration//GEN-END:variables
}
